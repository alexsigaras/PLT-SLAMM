<head><meta http-equiv="content-type" content="text/html; charset=ISO-8859-1"/><!-- Homework Assignment #2                         --><!-- Created by Al Aho on 2/24/2013                 --><!-- Last modified on 2/24/2013                     --><!-- -------------------------------------------------><title>Homework #2</title></head><body>
 <h1 style="text-align: left;"> COMS W4115
  <br/>Programming Languages and Translators
  <br/>Homework Assignment #2
  <br/>Submit solutions electronically on
  <br/>     Courseworks/COMSW4115/Assignments
  <br/>     by 2:40pm, March 6, 2013
 </h1>
 <hr/><h2>Instructions</h2>
 <ul><li>Problems 1-4 are each worth 25 points.</li>
  <li>You may discuss the questions with others in the class but your answers
      must be in your own words and your own code. You must not copy someone
      else's solutions.
      If you consult others or use external sources, please cite the
      people or sources in your answers.</li>
  <li>Solutions to these problems will be posted
      on Courseworks on March 11, 2013.</li>
  <li>This assignment may submitted electronically on Courseworks by 2:40pm,
      March 11, 2013 for 50% credit.</li>
  <li>Pdf files are preferred.</li>
 </ul><h2>Problems</h2>
 <ol><li>Interactive desk calculator for boolean nor-expressions.</li>
  <ol style="list-style-type: lower-alpha;"><li>Construct a grammar that generates
      boolean nor-expressions
      containing the logical
      constants <code>true</code> and <code>false</code>, the
      left-associative binary boolean operator
      <code>nor</code> [where <code>p nor q</code>
      means not (p or q)], and
      parentheses.</li>
  <li>Show the parse tree according to your grammar for the nor-expression</li>
      <dt>   <code>true nor true nor (false nor false)</code></dt>
  <li>Implement an interpreter that takes as input newline-terminated
      lines of boolean nor-expressions and produces as
      output the truth value of each expression.
      You can use lex and yacc or their equivalents
      to implement your interpreter.  Show the source
      code for your interpreter and the sequences of
      commands you used to test it.</li>
  <li>Run your interpreter on the following two inputs and show the outputs:</li>
      <dt>   (a) <code>(true nor false) nor (true nor false)</code></dt>
      <dt>   (b) <code>true nor true nor (false nor false)</code></dt>
  </ol><br/><li>Infix to stack machine code translator</li>
  <ol style="list-style-type: lower-alpha;"><li>Consider the Yacc specification in Fig. 4.59 of ALSU (p. 292).
       Modify this translator to produce stack machine code for
       each input line.  For example, for the input "1*(2+3)" your translator
       should produce the instructions</li>

<pre><code>push 1
push 2
push 3
add
multiply
done
</code></pre>

   <li>Implement your translator in Yacc (or its equivalent) and show the
       stack machine code generated for each of the following inputs:</li>
      <dt>    (i) <code>1+2*3</code></dt>
      <dt>   (ii) <code>1+(2-3)</code></dt>
      <dt>  (iii) <code>1+2-+3</code></dt>
      <dt>  (iv) <code>1+2--3</code></dt>
  </ol><br/><li>Let <i>L</i> be the language generated by the following grammar:</li>
<pre><code>
S → a S b S | b S a S | ε
</code></pre>

  <ol style="list-style-type: lower-alpha;"><li>What language does this grammar generate?</li>
   <li>Show that this grammar is ambiguous.</li>
   <li>Construct the predictive parsing table for this grammar.</li>
   <li>Construct an LL(1) grammar for <i>L</i>.</li>
   <li>Construct the predictive parsing table for your grammar.</li>
  </ol><br/><li>Let <i>L</i> be the language of pure lambda calculus
      expressions generated by the following grammar:</li>
<pre><code>
E → ^ v . E  | E E | ( E ) | v
</code></pre>
      <dt>The symbols <code>^, ., (, )</code> and <code>v</code> are tokens.
          <code>^</code> represents lambda and
          <code>v</code> represents a variable.<dt>
      <dt>An expression of the form <code>^v.E</code> is a function definition
          where <code>v</code> is the formal parameter of the function and
          <code>E</code> is its body.</dt>
      <dt>If <i>f</i> and <i>g</i> are lambda expressions, then the lambda
          expression <i>fg</i> represents the application of the function <i>f</i>
          to the argument <i>g</i>.</dt>
      
      

  <ol style="list-style-type: lower-alpha;"><li>Show that this grammar is ambiguous.</li>
   <li>Construct an unambiguous grammar for <i>L</i> assuming that
       function application is left associative, e.g., <i>fgh</i> = (<i>fg</i>)<i>h</i>,
       and that function application binds tighter than <code>.</code>,
       e.g., (^<i>x</i><code>.</code> ^<i>y</i><code>.</code> <i>xy</i>)
       ^<i>z</i><code>.</code><i>z</i> =
       (^<i>x</i>. (^<i>y</i>. <i>xy</i>)) ^<i>z</i>.<i>z</i>.</li>
   <li>Using your grammar, construct a parse tree for the expression
       (^<i>x</i><code>.</code> ^<i>y</i><code>.</code> <i>xy</i>) ^<i>z</i><code>.</code><i>z</i>.
   </li><li>Using the command <code>yacc -v</code> on a file containing your grammar,
       show the LALR(1) parsing action and goto table for your grammar.</li>


 </ol><br/><hr/><address><a href="mailto:aho@cs.columbia.edu">aho@cs.columbia.edu</a></address> 

</dt></dt></ol></body>