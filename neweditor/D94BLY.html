<head><meta http-equiv="content-type" content="text/html; charset=ISO-8859-1"/><title>Lecture 6: February 11, 2013</title></head><body>
 <h1>COMS W4115<br/>
  Programming Languages and Translators<br/>
  Lecture 6: Context-Free Grammars<br/>
  February 11, 2013
 </h1>

 <h2>Lecture Outline</h2>
 <ul><li>Context-free grammars</li>
  <li>Derivations and parse trees</li>
  <li>Ambiguity</li>
  <li>Examples of context-free grammars</li>
  <li>Yacc: a language for specifying syntax-directed translators</li>  
 </ul><h2>1. Context-Free Grammars (CFG's)</h2>
 <ul><li>CFG's are very useful for representing the syntactic structure
      of programming languages.</li>
  <li>A CFG is sometimes called Backus-Naur Form (BNF).</li>
  <li>A context-free grammar consists of</li>
  </ul><ol><li>A finite set of terminal symbols,</li>
   <li>A finite nonempty set of nonterminal symbols,</li>
   <li>One distinguished nonterminal called the start symbol, and</li>
   <li>A finite set of rewrite rules, called productions, each of the form
       A → α
       where A is a nonterminal and α is a string (possibly empty)
           of terminals and nonterminals.</li>
  </ol><br/><li>Consider the context-free grammar G with the productions</li>
  <pre><code>
      E → E + T | T
      T → T * F | F
      F → ( E ) | id
  </code></pre>
 <ul><li>The terminal symbols are the alphabet from which strings are formed.
      In this grammar the set of terminal symbols is
      { id, +, *, (, ) }.  The terminal symbols are the token names.</li>
  <li>The nonterminal symbols are syntactic variables that denote sets
      of strings of terminal symbols. In this grammar the set of nonterminal
      symbols is { <code>E</code>, <code>T</code>, <code>F</code>}.</li>
  <li>The start symbol is <code>E</code>.</li>
 </ul><h2>2. Derivations and Parse Trees</h2>
 <ul><li><i>L</i>(G), the language generated by a grammar G, consists of all strings of
    terminal symbols that can be derived from the start symbol of G.</li>
 
  <li>A leftmost derivation expands the leftmost nonterminal in
      each sentential form:</li>
  </ul><pre><code>
      E ⇒ E + T
        ⇒ T + T
        ⇒ F + T
        ⇒ id + T
        ⇒ id + T * F
        ⇒ id + F * F
        ⇒ id + id * F
        ⇒ id + id * id
  </code></pre>
 
  <li>A rightmost derivation expands the rightmost nonterminal in each sentential form:</li>
  <pre><code>
      E ⇒ E + T
        ⇒ E + T * F
        ⇒ E + T * id
        ⇒ E + F * id
        ⇒ E + id * id
        ⇒ T + id * id
        ⇒ F + id * id
        ⇒ id + id * id
  </code></pre>
  <li>Note that these two derivations have the same parse tree.</li>
 
 
 <h2>3. Ambiguity</h2>
 <ul><li>Consider the context-free grammar G with the productions</li>
  </ul><pre><code>
      E → E + E | E * E | ( E ) | id
  </code></pre>
 
 <li>This grammar has the following leftmost derivation for
     <code>id + id * id</code>
  <pre><code>
      E ⇒ E + E
        ⇒ id + E
        ⇒ id + E * E
        ⇒ id + id * E
        ⇒ id + id * id
  </code></pre>
 </li>
 
 <li>This grammar also has the following leftmost derivation for
     <code>id + id * id</code>
  <pre><code>
      E ⇒ E * E
        ⇒ E + E * E
        ⇒ id +  E * E
        ⇒ id + id * E
        ⇒ id + id * id
  </code></pre>
  </li>
 
  <li>These derivations have different parse trees.</li>
  <li>A grammar is <i>ambiguous</i> if there is a sentence with two
      or more parse trees.</li>
  <li>The problem is that the grammar above does not specify</li>
  <ul><li>the precedence of the + and * operators, or</li>
   <li>the associativity of the + and * operators</li>
  </ul><li>However, the grammar in section (3) generates the same language
      and is unambiguous because
      it makes * of higher precedence than +, and makes both operators
      left associative.</li>
  <li>A context-free language is <i>inherently ambiguous</i> if it
      cannot be generated by any unambiguous context-free grammar.</li>
  <li>The context-free language
      { <code>a<sup><i>m</i></sup>b<sup><i>m</i></sup>a<sup><i>n</i></sup>b<sup><i>n</i></sup></code>
      | <i>m</i> &gt; 0 and <i>n</i> &gt; 0} ∪
      { <code>a<sup><i>m</i></sup>b<sup><i>n</i></sup>a<sup><i>n</i></sup>b<sup><i>m</i></sup></code>
      | <i>m</i> &gt; 0 and <i>n</i> &gt; 0}
      is inherently ambiguous.</li>
  <li>Most (all?) natural languages are inherently ambiguous but no
      programming languages are inherently ambiguous.</li>
  <li>Unfortunately, there is no algorithm to determine whether a CFG is ambiguous;
      that is, the problem of determining whether a CFG is ambiguous is undecidable.</li>
  <li>We can, however, give some practically useful sufficient conditions to guarantee that a CFG
      is unambiguous.</li>
 

 <h2>4. Examples of Context-Free Grammars</h2>
 <ul><li>Nonempty palindromes of <code>a</code>'s and <code>b</code>'s.
       (A palindrome is a string that reads the same forwards as backwards;
        e.g., <code>abba</code>.)</li>
   <dt>CFG: <code>S → a S b | b S a | a a | b b | a | b</code></dt>
   <dt>Note that the language generated by this grammar is not regular.
       Can you prove this using the pumping lemma for regular languages?</dt><br/><li>Strings with an equal number of <code>a</code>'s and <code>b</code>'s:</li>
   <dt>CFG: <code>S → a S a | b S b | S S | ε</code></dt>
   <dt>Note that this grammar is ambiguous.
       Can you find an equivalent unambiguous grammar?</dt><br/><li>If- and if-else statements:</li>
   </ul><pre><code>
      stmt → if ( expr ) stmt else stmt
           | if (expr) stmt
           | other
   </code></pre>
   <dt>Note that this grammar is ambiguous.</dt><br/><li>Some typical programming language constructs:</li>
   <pre><code>
      stmt → expr ;
           | if (expr) stmt
           | for ( optexpr; optexpr; optexpr;) stmt
           | other
      optexpr → ε
           | expr
   </code></pre>

  

 <h2>5. Yacc: a Language for Specifying Syntax-Directed Translators</h2>
 <ul><li>Yacc is popular language, created by
      Steve Johnson of Bell Labs, for implementing syntax-directed
      translators.</li>
  <li>Bison is a gnu version of Yacc, upwards compatible with the original Yacc,
      written by Charles Donnelly and Richard Stallman.
      Many other versions of Yacc are also available.</li>
  <li>The original Yacc used C for semantic actions. Yacc has been rewritten for
      many other languages including Java, ML, OCaml, and Python.</li>
  <li>Yacc specifications</li>
  <ul><li>A Yacc program has three parts:</li>

   </ul></ul><pre>      <i>declarations</i>
      <code>%%</code>
      <i>translation rules</i>
      <code>%%</code>
      <i>supporting C-routines</i>
   </pre>

   <dt>The declarations part may be empty and the last part (<code>%%</code>
       followed by the supporting C-routines) may be omitted.</dt><br/><br/><li>Here is a Yacc program for a desk calculator
      that adds and multiplies numbers.
      (See ALSU, p. 292, Fig. 4.59 for a more advanced desk calculator.)</li>

  <pre><code>
      %{
      #include &lt;ctype.h&gt;

      #include &lt;stdio.h&gt;
      #define YYSTYPE double
      %}

      %token NUMBER
      %left '+'
      %left '*'

      %%

      lines : lines expr '\n'   { printf("%g\n", $2); }
            | lines '\n'
            | /* empty */
            ;

      expr  : expr '+' expr      { $$ = $1 + $3; }
            | expr '*' expr      { $$ = $1 * $3; }
            | '(' expr ')'       { $$ = $2; }
            | NUMBER
            ;

      %%
      /* the lexical analyzer; returns &lt;token-name, yylval&gt; */
      int yylex() {
        int c;
        while ((c = getchar()) == ' ');
        if ((c == '.') || (isdigit(c))) {
          ungetc(c, stdin);
          scanf("%lf", &amp;yylval);
          return NUMBER;
        }
        return c;
      }
  </code></pre>

  <li>The declarations</li>
  <dt><code>%left '+'</code></dt>
  <dt><code>%left '*'</code></dt>
  <dt>make the operator <code>+</code> left associative and of lower
      precedence than the left-associative operator <code>*</code>.</dt>


  <li>On Linux, we can make a desk calculator from this Yacc program
      as follows:</li><br/><ol><li>Put the yacc program in a file, say <code>desk.y</code>.</li>
    <li>Invoke <code>yacc desk.y</code> to create the yacc output file <code>y.tab.c</code>.</li>
    <li>Compile this output file with a C compiler by typing <code>gcc y.tab.c -ly</code>
        to get <code>a.out</code>.
        (The library -ly contains the Yacc parsing program.)</li>
    <li><code>a.out</code> is the desk calculator. Try it!</li>
   </ol><br/><h2>6. Practice Problems</h2>
 <ol><li>Let G be the grammar
      S → a S b S | b S a S | ε.
  <ol style="list-style-type: lower-alpha;"><li>What language is generated by this grammar?</li>
   <li>Draw all parse trees for the sentence <code>abab</code>.</li>
   <li>Is this grammar ambiguous?</li>
  </ol></li>
  <li>Let G be the grammar
      S → a S b | ε.
      Prove that <i>L</i>(G) = 
      { <code>a</code><sup><i>n</i></sup><code>b</code><sup><i>n</i></sup> | <i>n</i> ≥ 0 }.
  </li>
  <li>Consider a sentence of the form <code>id + id + ... + id</code> where there are
      <i>n</i> plus signs. Let G be the grammar in section (3) above.
      How many parse trees are there in G for this sentence when <i>n</i> equals</li>
  <ol style="list-style-type: lower-alpha;"><li>1</li>
   <li>2</li>
   <li>3</li>
   <li>4</li>
   <li><i>m</i>?</li>
  </ol><li>Write down a CFG for regular expressions over the alphabet {<code>a</code>, <code>b</code>}.
      Show a parse tree for the regular expression <code>a | b*a</code>.</li>
 </ol><h2>7. Reading</h2>
 <ul><li>ALSU Sects. 4.1-4.2, 4.9</li>
  <li><a href="http://www.scribd.com/doc/8669780/Lex-yacc-Tutorial">
        A nice Lex &amp; Yacc tutorial</a></li>
 </ul><br/><hr/><address><a href="mailto:aho@cs.columbia.edu">aho@cs.columbia.edu</a></address>

</body>