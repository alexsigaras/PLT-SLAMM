<head><meta http-equiv="content-type" content="text/html; charset=windows-1252"/><title>Lecture 16, March 27, 2013</title></head><body>
 <h1>COMS W4115<br/>
  Programming Languages and Translators<br/>
  Lecture 16: Translation of Statements<br/>
  March 27, 2013
 </h1>

 <h2>Lecture Outline</h2>
 <ol><li>Logical rules of inference for type checking</li>
  <li>Run-time storage organization</li>
  <li>Translation of assignments</li>
  <li>arrays</li>
  <li>Boolean expressions</li>
  <li>If-statements</li>
  <li>While-statements</li>
 </ol><h2>1. Logical Rules of Inference for Type Checking</h2>
 <ul><li>Type inference templates</li>
  <ul><li>We can specify the type inference rule "if expression <code>e1</code> has the
       type <code>int</code> and expression <code>e2</code> has the type <code>int</code>,
       then the expression <code>e1 + e2</code> has the type <code>int</code>" with a type inference
       template of the form</li>
</ul></ul><pre>
⊢ e1: int     ⊢ e2: int
_______________________

    ⊢ e1 + e2: int
</pre>

   <li>The turnstile symbol ⊢ is read "it is provable that"
       so the template can be read as "if it is provable that <code>e1</code> has type <code>int</code>
       and it is provable
       that <code>e2</code> has type <code>int</code>,
       then it is provable that <code>e1 + e2</code> has type <code>int</code>."</li>
   <li>Templates of this form provide a compact way of expressing the type
       rules of a language.</li>
   <li>We say a type system is sound if whenever ⊢ <i>e</i>: <i>T</i> then <i>e</i> evaluates
       to a value of type <i>T</i>.</li>
   <li>We can apply the type-inference templates by making a bottom-up traversal of the AST.
       We determine the types of the leaves using information from the symbol table.
       We can then move up the tree determining the type of the interior nodes from the types
       of their children by applying the inference rule for the operator at a given interior node.</li>
  

 <li>Type environments</li>
 <ul><li>A type environment is often needed to determine the type of a variable
      at a given node in the AST.
      A type environment is just a mapping from variables to types that is stored in the symbol table.
      The type environment for each node can be determined by making
      a top-down pass over the AST respecting the type scoping rules of the language.</li>
  <li>The type inference rules are augmented with the type environment information.
      For example, if <code>E</code> is a type environment, we modify the template to make type
      inferences within the context of <code>E</code>:</li>
</ul><pre>
E ⊢ e1: int     E ⊢ e2: int
____________________________

    E ⊢ e1 + e2: int
</pre>
   <li>Static type checking can be done by making a top-down pass to compute the
       type environment for each node followed by a bottom-up pass to check the types
       at each node.</li> 
  
 


 <h2>2. Run-time Storage Organization</h2>
 <ul><li>Run-time memory layout</li>
  <ul><li>Typical memory layout</li>
   </ul></ul><pre><code>
   (low address) Code
                 Static data
                 Runtime heap
                   ↓

                 Free memory

                   ↑                                 
  (high address) Runtime stack
   </code></pre>
  
 

 <h2>3. Translation of Assignments</h2>
 <ul><li>Here is Fig. 6.20 (p. 381), an SDTS generating three-address code for
      assignments:</li>
</ul><pre><code>
S → id = E ; { gen(top.get(id.lexeme) '=' E.addr); }
E → E<sub>1</sub> + E<sub>2</sub>  { E.addr = new Temp();
               gen(E.addr '=' E<sub>1</sub>.addr '+' E<sub>2</sub>.addr); }
  | - E<sub>1</sub>     { E.addr = new Temp();
               gen(E.addr '=' 'uminus' E<sub>1</sub>.addr); }
  | ( E<sub>1</sub> )   { E.addr = E<sub>1</sub>.addr; }
  | id       { E.addr = top.get(id.lexeme); }
</code></pre>

  <li>Example. Here is the three-address code generated by this SDTS
      for the assignment statement:  <code>a = b + -c;</code></li>
  <pre><code>
  t1 = uminus c
  t2 = b + t1
  a = t2
  </code></pre>
 

 <h2>4. Arrays</h2>
 <ul><li>Referencing a one-dimensional array</li>
  <ul><li>In C and Java, array elements are numbered <code>0, 1,..., n-1</code>
       for an array <code>A</code> with n elements.</li>
   <li>Element <code>A[i]</code> begins in location <code>(base + i × w)</code>
       where <code>base</code> is the relative address of the storage allocated for
       <code>A</code> and <code>w</code> is the width of each element.</li>
  </ul><li>Common layouts for multidimensional arrays</li>
  <ul><li>Row-major order</li>
   <li>Column-major order</li>
  </ul><li>See Fig. 6.22 (p. 383) for an SDD generating three-address code for
      assignments with array references.</li>
  <li>Example: three-address code for the expression
      <code>c + a[i][j]</code> assuming the width of an integer is 4</li>
  </ul><pre><code>
  t1 = i * 12
  t2 = j * 4
  t3 = t1 + t2
  t4 = a[t3]
  t5 = c + t4
  </code></pre>
 

 <h2>5. Boolean Expressions</h2>
 <ul><li>Boolean expressions are composed of boolean operators (&amp;&amp;, ||, !)
      applied to boolean variables, relational expressions, and other
      boolean expressions.</li>
  <li>Short-circuit evaluation: Some languages, such as C and Java, do not require an entire boolean
      expression to be evaluated.</li>
  <ul><li>Given <code>x &amp;&amp; y</code>, if <code>x</code>
       is false, then we can conclude the entire expression is false without
       evaluating <code>y</code>.</li>
   <li>Given <code>x || y</code>, if <code>x</code>
       is true, then we can conclude the entire expression is true without
       evaluating <code>y</code>.</li>
  </ul><li>Numerical encoding</li>
  <ul><li>In C, the numerical value 0 represents false; a nonzero value represents true.</li>
  </ul><li>Positional encoding</li>
  <ul><li>The value of a boolean expression can be represented by a position in three-address
       code, and the boolean operators can be translated into jumps.</li>
   <li>The expression</li>
       </ul></ul><pre><code>
       if (x &lt; 100 || x &gt; 200 &amp;&amp; x != y)
         x = 0;
       </code></pre>
       <dt>can be translated into the following three-address instructions:</dt>
       <pre><code>
           if x &lt; 100 goto L2
           ifFalse x &gt; 200 goto L1
           ifFalse x != y goto L1
       L2: x = 0
       L1:
       </code></pre>
   
 

 <h2>6. Translation of If-statements</h2>
 <ul><li>Boolean expressions often appear in the context of flow-of-control statements
      such as:</li>
  <ul><li>If statements</li>
   <li>If-else statement </li>
  </ul><li>See Figs. 6.36 (p. 402) and 6.37 for SDDs translating these statements
      with booleans into three-address code.</li>
  <li>For the expression</li>
       </ul><pre><code>
       if (x &lt; 100) || x &gt; 200 &amp;&amp; x != y)
         x = 0;
       </code></pre>
       <dt>these SDDs produce the following three-address instructions:</dt>
       <pre><code>
           if x &lt; 100 goto L2
           goto L3
       L3: if x &gt; 200 goto L4
           goto L1
       L4: if x != y goto L2
           goto L1
       L2: x = 0
       L1:
       </code></pre>
       <dt>This code can be transformed into the code in Section 5 by eliminating the redundant goto
           and changing the directions of the tests in the second and third if-statements.</dt>
 

 <h2>7. Translation of While-statements</h2>
 <ul><li>Consider the production <code>S → while ( B ) S1</code>
      for while-statements.
      The shape of the code for implementing this production
      can take the form:</li>

  </ul><pre><code>
   begin: // beginning of code for S
      code to evaluate B
      if B is true goto B.true
      if B is false goto B.false
   B.true:
      code to evaluate S1
      goto begin
   B.false:  // this is where control flow will go after executing S
  </code></pre>

  <li>Here is an SDD for this translation (from Fig. 6.36, p. 402):</li>

  <pre><code>
   S → while ( B ) S1 {
            begin = newlabel()
            B.true = newlabel()
            B.false = S.next
            S1.next = begin
            S.code = label(begin) || B.code ||
                     label(B.true) || S1.code ||
                     gen('goto' begin)
   }
  </code></pre>

 

 <h2>8. Practice Problems</h2>
 <ol><li>Use the SDD of Fig. 6.22 (ALSU, p. 383) to translate the assignment
      <code>x = a[i][j] + b[i][j]</code>.</li>
  <li>Add rules to the SDD in Fig. 6.36 (ALSU, p. 402) to translate
      do-while statements of the form:</li>
      <dt>   <i>S</i> → <b>do</b> <i>S</i> <b>while</b> <i>B</i></dt>
      <dt>Show the code your SDD would generate for the program</dt><dt>
  <pre><code>
     do
       do
         assign1
       while a &lt; b
     while c &lt; d
  </code></pre>
 </dt></ol><h2>9. Reading</h2>
 <ul><li>ALSU, Sections 6.4 - 6.8, 7.1</li>
 </ul><br/><hr/><address><a href="mailto:aho@cs.columbia.edu">aho@cs.columbia.edu</a></address>

</body>